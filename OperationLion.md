### Assembly Reversing WriteUp - 
# CTF Summary Exercise - Operation Lion 

Submitted by: Shirel Sananes 322328814
________________________________________________________________________________

### שלב 1: נטרול מערכת נ"מ

### **מטרה**

לנטרל סוללת נ"מ ולהגן על טייסים, תוך כדי הרצת הקובץ, הודפסו הודעות שמדגישות שישנם "פיתיונות" של האויב, וצריך לאתר את המטרה האמיתית במהירות.
הודעת שגיאה בסיום השלב הייתה: Danger! Anti aircraft system is still operating

### ניתוח הקוד:
#### 1. הבנת מבנה הפונקציה main: 
בתוך main, מתבצעים השלבים הבאים:

1. הדפסות ועיצוב טקסטואלי של הודעת השלב.
2. הפונקציה sub_401290 מדפיסה תווים באפקט איטי - שינוי שם הפונקציה בקוד שלי: Print_char_by_char
3. שליפת שני ערכים מהזיכרון הקבוע:
   
• משתנה ראשון: dword_405474 = 0x61646152 (מחרוזת 'R' 'a' 'd' 'a')
   
• משתנה שני: word_405478 = 0x72 (תו 'r')
   
← שילוב הערכים נותן את המחרוזת "Radar"

שני הערכים מאוחסנים בזיכרון המקומי (stack) ומועברים כמצביע לפונקציה sub_4013B0 (שינוי שם שלי בקוד: Xor2A_Double_NoEffect)

• ניתוח sub_4013B0:

הפונקציה מבצעת עיבוד על המחרוזת שהועברה לה:
1. מחושבת האורך של המחרוזת באמצעות לולאה שמחפשת את תו הסיום (\0)
2. לאחר מכן יש לולאה שמבצעת פעמיים XOR 0x2A על כל תו

המשמעות של הפעולה:

```c
for (i = 0; i < strlen(str); i++) {
    str[i] ^= 0x2A;
    str[i] ^= 0x2A;
}
```
מכיוון ש־XOR עם אותו ערך פעמיים מחזיר את הערך המקורי, הפונקציה לא משנה דבר בפועל. היא ככל הנראה נועדה לבלבל.

• ניתוח sub_401330:
  1. מאתחלת משתנה לערך '{' (0x7B)
  2. מריצה לולאה 5 פעמים:
```c
v = (i * 7) ^ v;
```
בסוף הלולאה, התוצאה היא v = 2
  
  3. קוראת לפונקציות הבאות:

### ניתוח פונקציית sub_4012E0:
הפונקציה מקבלת פרמטר מספרי (`arg_0`) ומחזירה ערך בהתאם לשארית החלוקה ב־3:

- אם שארית החלוקה היא 0 ← מחזירה `arg_0 * 2`
- אם שארית החלוקה היא 1 ← מחזירה `arg_0 + 100`
- אם שארית החלוקה היא 2 ← מחזירה `arg_0 - 50`

כלומר, עבור הקלט 2, הפונקציה מחזירה 48-.

 ### ניתוח הפונקציה sub_401430:

הפונקציה בודקת האם קיום קובץ בנתיב מסוים ומגיבה בהתאם לתוצאה.

#### מהלך הפעולה:

1. הפונקציה יוצרת את הנתיב: `C:\ReversingCTF\DroneAttack.txt`

2. לאחר מכן, מבוצעת בדיקה האם הקובץ קיים בעזרת הקריאה `FindFirstFileA`.

3. אם הקובץ **נמצא**:
- מודפסת ההודעה: `"Anti aircraft system located Intiating disable sequence..."`
- מתבצע ניסיון לפתוח את הקובץ עם CreateFileA בשביל להמשיך.

4. אם הקובץ **לא נמצא**:
- מודפסת ההודעה: `"Danger! Anti aircraft system is still online!"`

### **פתרון**

לצורך קבלת הודעת ההצלחה בשלב זה, יש לוודא כי הקובץ הבא קיים: `C:\ReversingCTF\DroneAttack.txt`

יצירת הקובץ באופן ידני איפשרה התקדמות לשלב הבא:
```sql
Anti aircraft system located
Initiating disable sequence
Great job. Anti aircraft system is disabled
Stage 2: You are a jet fighter pilot. The sky is clear...
```

### שלב 2: 



### ניתוח הפונקציה sub_3C1390:

* חתימת הפונקציה: int sub_3C1390(int a, int b)
```asm
mov     eax, [ebp+arg_0]     ; eax = a
xor     eax, [ebp+arg_4]     ; eax = a ^ b

mov     ecx, [ebp+arg_0]     
and     ecx, [ebp+arg_4]     ; ecx = a & b
add     eax, ecx             ; eax = (a ^ b) + (a & b)

mov     edx, [ebp+arg_0]     
or      edx, [ebp+arg_4]     ; edx = a | b
sub     eax, edx             ; eax = ((a ^ b) + (a & b)) - (a | b)
retn
```
בפועל הפונקציה מחשבת: result = (A ^ B) + (A & B) - (A | B) שזה שווה ← return (a + b) - (a | b)

כלומר, הפונקציה מחזירה את ההפרש בין סכום שני המספרים לבין תוצאת פעולת OR עליהם.

המשמעות: כמה ביטים מיותרים נוספו ב־OR לעומת סכום מדויק.

ייתכן שהמטרה היא להסתיר פעולה פשוטה מתוך ניסיון להקשות על רברסינג.








