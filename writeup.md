# Assembly Reversing Writeup

This document contains explanations and solutions for Assembly reversing exercises.
It focuses on Wonderland challenges — Stages 2 and 3 — including analysis and recovery of the correct inputs.

## Exercise: Wonderland 2

#### תיאור כללי

הפונקציה מקבלת מחרוזת קלט (`Buffer`), מבצעת עליה עיבוד XOR בבלוקים של 4 בתים עם מפתח קבוע (`0x41524241`), ומשווה את התוצאה למחרוזת מטרה קבועה ("into the rabbit hole").
אם המחרוזת המפוענחת תואמת למחרוזת המטרה, מתבצעת קפיצה לאזור קוד המאשר הצלחה.


#### שלבי פעולת הקוד:

* **מצב התחלתי -בדיקת דגל**
  
בתחילת הקוד, נטען הערך `1` לרגיסטר `eax`, כהגדרת דגל הצלחה כברירת מחדל.
לאחר מכן מתבצעת הפקודה `test eax, eax`, שבודקת אם `eax` שווה ל־0 (באמצעות AND עם עצמו) פעולה זו משפיעה על דגל האפס (ZF-Jump if Zero) מבלי לשנות את תוכן הרגיסטר.
אם הערך היה 0, פקודת הקפיצה `jz` הייתה מעבירה את הביצוע לכתובת `loc_401427`, שם מתבצעת סיום הפונקציה (`mov esp, ebp`, `pop ebp`, `retn`).
מכיוון ש־`eax` שווה ל־1, הקפיצה אינה מתבצעת והקוד ממשיך לרוץ כרגיל.

* **ניקוי הזיכרון (memset)**

הפונקציה memset ממומשת כאן כ־Thunk – כלומר, הפנייה ישירה לפונקציה החיצונית __imp_memset באמצעות פקודת jmp.
הפונקציה עצמה ממלאת אזור בזיכרון בערך קבוע על פי שלושה פרמטרים:

* ערך (Val) , מספר הבתים למילוי (Size),  כתובת ההתחלה (Buffer)

הקריאה לפונקציה מתבצעת לפי מוסכמת הקריאה cdecl, כך שהפרמטרים נדחפים למחסנית בסדר הבא:


  ```asm
  push    400h            ; Size – מספר הבתים למילוי (1024)
  push    0               ; Val – הערך למילוי (0)
  lea     ecx, [ebp+Buffer]
  push    ecx             ; ptr – מצביע לתחילת אזור הזיכרון
  call    memset
  ```

  בקריאה זו, הפונקציה תבצע מילוי של 1024 בתים מהכתובת `Buffer` בערך 0x00, וכך מאפסת את הזיכרון לפני קריאת הקלט.
  
  * **קריאת מחרוזת מהקלט (fgets)**
  
  לאחר מכן, הפונקציה קוראת מחרוזת מהקלט אל המשתנה `Buffer` באמצעות `fgets`, עם אורך מקסימלי של 1023 תווים (0x3FF).
  ומתבצעת קריאה לפונקציה `__acrt_iob_func` לקבלת מצביע לקלט, ואז `fgets` קוראת את הטקסט ל־Buffer.

  * **חישוב אורך המחרוזת**

 האורך של המחרוזת שנקלטה נשמר במשתנה מקומי (`var_C`) באמצעות קריאה ל־`strlen`

  * **לולאת עיבוד XOR** - מבוצעת לולאה החוזרת על מחרוזת הקלט בבלוקים של 4 בתים:
    
  1. בכל איטרציה, ארבעת הבתים ב־Buffer עוברים XOR עם מפתח קבוע 0x41524241.
  2. התוצאה נשמרת בחזרה במיקום המתאים ב־Buffer.
  3. הלולאה ממשיכה כל עוד i + 3 < strlen(Buffer).
  
  * **השוואת מחרוזות**
  
  לאחר סיום הפענוח, מבוצעת השוואת מחרוזת בין התוצאה המפוענחת (Buffer) לבין המחרוזת `"into the rabbit hole"`.
  ההשוואה מתבצעת באמצעות `strncmp`.
  אם אורך המחרוזת שווה (`eax == 0`), מתבצעת קפיצה לחלק שמדפיס שהסיסמה נכונה (`loc_401413`).

  * **פונקצית סיום -**
    בסיום מתבצעת פעולת ניסוי המחסנית הקריאות (`mov esp, ebp` ו־`pop ebp`) ואז `retn`.
    
---
#### **פתרון - פענוח באמצעות סקריפט פייתון**

כדי לפתור את שלב 2 ולמצוא את הסיסמה הנכונה, היה צריך לבצע את הפעולה ההפוכה לזו שבוצעה בתוכנית —

כלומר, **לבצע XOR הפוך** על המחרוזת `"into the rabbit hole"`, בעזרת סקריפט Python -
הפונקציה xor_decrypt מבצעת XOR על המחרוזת עם אותו מפתח, ומחזירה את המחרוזת המפוענחת.

להלן הסקריפט שבוצע:


![case2](https://github.com/shirelsan/Assembly-Reversing/blob/main/case2_py.png?raw=true) 


* הסבר על הפונקציה:

הפונקציה xor_decrypt מפענחת מחרוזת בתים (bytes) על ידי שימוש במפתח XOR בן 4 בתים (32 ביט).
הפונקציה מחלקת את המחרוזת לבלוקים של 4 בתים, מבצעת על כל בלוק פעולת XOR עם המפתח, ומחזירה את התוצאה המפוענחת באותו אורך כמו הקלט.
אם הבלוק האחרון קצר מ-4 בתים, מתווספים אפסים כדי להשלים אותו.

הסיסמה שקיבלנו: **(,&.a6:$a03##+&a)->$**

![case2](https://github.com/shirelsan/Assembly-Reversing/blob/main/case2-sol.png?raw=true) 


## Exercise: Wonderland 3

#### תיאור כללי
הקוד מצפה לקלט מהמשתמש, המורכב מ־8 מספרים מסוג unsigned (באמצעות %hu), ומבצע עבורם אימות.
הקלט מומר לערכים חתומים (signed) בגודל 16 ביט, תוך שימוש במערך המרה (word_404000) המאוחסן בזיכרון. ההמרה מתבצעת בפורמט Little Endian.

במהלך האימות נבדק האם סדר הערכים שהתקבל לאחר ההמרה הוא ממוין בסדר עולה. אם הסדר תקין – הקוד ממשיך בביצוע (כלומר, מעיד על הצלחה). אחרת, תודפס הודעת שגיאה.


#### שלבי פעולת הקוד:
**1. קבלת קלט מהמשתמש**
המשתמש מתבקש להזין 8 ערכים מסוג unsigned (%hu).
הקלט נקלט לתוך מערך בזיכרון (var_18), כאשר כל ערך תופס 2 בתים (16 ביט).

**2. בדיקה ראשונית לכל אחד מהערכים:**

מתבצעת לולאה העוברת על כל אחד מ־8 הערכים:

  • נבדק שהפונקציה scanf("%hu", ...) קלטה ערך אחד תקין.

  • נבדק שכל ערך בקלט הוא קטן מ־8 (value < 8).

  • אם אחת הבדיקות נכשלת, תודפס ההודעה:

"Bad or invalid numbers! Try again from the beginning."
  
  כלומר, תתרחש שגיאה (var_8 = 1) וידלג להמשך (ללא בדיקת הסדר).

**3. אם הקלט תקין – מתבצעת בדיקת סדר עולה על הערכים הממופים**

  במידה ולא התגלתה שגיאה בשלבים הקודמים, מועבר מצביע למערך הקלט לפונקציה sub_4014F0.

**4. פענוח הערכים באמצעות טבלת המרה (word_404000)** 

בתוך הפונקציה sub_4014F0:

  • כל ערך מתוך מערך הקלט משמש כאינדקס ל־word_404000.

  • נשלף הערך המתאים מתוך word_404000, ונשמר כ־signed 16-bit בפורמט Little Endian.

  • הערכים מורצים בזה אחר זה, ובכל איטרציה נבדק האם הערך הנוכחי גדול מהקודם.

**5. בדיקת סדר עולה**
הפונקציה בודקת האם כל הערכים הממופים מהקלט (באמצעות טבלת ההמרה) נמצאים בסדר עולה.

ההשוואה מתבצעת כ־signed (כלומר, הערכים יכולים להיות גם שליליים). אם ערך נוכחי קטן או שווה לקודם – הפונקציה מחזירה 0.

אחרת, אם כל הבדיקות עוברות – הפונקציה מחזירה 1.

אם הפונקציה החזירה 1 -> הקוד ימשיך ויאשר את הסיסמה. 

אם הפונקציה החזירה 0 -> תתודפס ההודעה: 
"Wrong! Try again."


#### **מציאת הסיסמה - פתרון באמצעות Python **

כדי למצוא את הסיסמה, יש למיין את שמונת הערכים שבמערך לפי סדר עולה – לפי ערכם כ־מספרים חתומים (signed 16-bit).

במקום למיין את הערכים עצמם, נחפש סדרת אינדקסים שמהווים קלט נכון – כך שהגישה לערכים במערך לפי אינדקסים אלה תביא לסדרה ממוינת.

לשם כך, באמצעות פייתון הסקרייפ: 

  • ממיר את זוגות הבתים במערך ל־8 ערכים חתומים, לפי פורמט little endian.

  • ממיין את האינדקסים לפי הערכים.

  • מחזיר את סדרת האינדקסים שמייצגת את הסיסמה הנכונה.

 ```python
import struct

# The data as found at address word_404000 (in little endian format)
data_bytes = bytes([
    0x07, 0x00,  # 0
    0x21, 0x00,  # 1
    0x01, 0x00,  # 2
    0xA8, 0xFD,  # 3
    0x78, 0xEC,  # 4
    0xF1, 0x06,  # 5
    0x0D, 0x00,  # 6
    0x45, 0x00   # 7
])
# Read 8 signed short values (2 bytes each) from the byte sequence
values = list(struct.unpack('<8h', data_bytes))

# Create a list of indices that would sort the values in ascending order
sorted_indices = sorted(range(8), key=lambda i: values[i])

print("\npassword:")
print(' '.join(map(str, sorted_indices)))
 ```

![case3 py](https://github.com/shirelsan/Assembly-Reversing/blob/main/case3_py.png?raw=true)


הסיסמה שקיבלנו: **5 7 1 6 0 2 3 4**

![case3 sol](https://github.com/shirelsan/Assembly-Reversing/blob/main/case_3-sol.png?raw=true) 
