# Assembly Reversing Writeup

This document contains explanations and solutions for Assembly reversing exercises.
It focuses on Wonderland challenges — Stages 2 and 3 — including analysis and recovery of the correct inputs.

## Exercise: Wonderland 2

#### תיאור כללי

הפונקציה מקבלת מחרוזת קלט (`Buffer`), מבצעת עליה עיבוד XOR בבלוקים של 4 בתים עם מפתח קבוע (`0x41524241`), ומשווה את התוצאה למחרוזת מטרה קבועה ("into the rabbit hole").
אם המחרוזת המפוענחת תואמת למחרוזת המטרה, מתבצעת קפיצה לאזור קוד המאשר הצלחה.


#### שלבי פעולת הקוד:

* **מצב התחלתי -בדיקת דגל**
  
בתחילת הקוד, נטען הערך `1` לרגיסטר `eax`, כהגדרת דגל הצלחה כברירת מחדל.
לאחר מכן מתבצעת הפקודה `test eax, eax`, שבודקת אם `eax` שווה ל־0 (באמצעות AND עם עצמו) פעולה זו משפיעה על דגל האפס (ZF-Jump if Zero) מבלי לשנות את תוכן הרגיסטר.
אם הערך היה 0, פקודת הקפיצה `jz` הייתה מעבירה את הביצוע לכתובת `loc_401427`, שם מתבצעת סיום הפונקציה (`mov esp, ebp`, `pop ebp`, `retn`).
מכיוון ש־`eax` שווה ל־1, הקפיצה אינה מתבצעת והקוד ממשיך לרוץ כרגיל.

* **ניקוי הזיכרון (memset)**

הפונקציה memset ממומשת כאן כ־Thunk – כלומר, הפנייה ישירה לפונקציה החיצונית __imp_memset באמצעות פקודת jmp.
הפונקציה עצמה ממלאת אזור בזיכרון בערך קבוע על פי שלושה פרמטרים:

* ערך (Val) , מספר הבתים למילוי (Size),  כתובת ההתחלה (Buffer)

הקריאה לפונקציה מתבצעת לפי מוסכמת הקריאה cdecl, כך שהפרמטרים נדחפים למחסנית בסדר הבא:


  ```asm
  push    400h            ; Size – מספר הבתים למילוי (1024)
  push    0               ; Val – הערך למילוי (0)
  lea     ecx, [ebp+Buffer]
  push    ecx             ; ptr – מצביע לתחילת אזור הזיכרון
  call    memset
  ```

  בקריאה זו, הפונקציה תבצע מילוי של 1024 בתים מהכתובת `Buffer` בערך 0x00, וכך מאפסת את הזיכרון לפני קריאת הקלט.
  
  * **קריאת מחרוזת מהקלט (fgets)**
  
  לאחר מכן, הפונקציה קוראת מחרוזת מהקלט אל המשתנה `Buffer` באמצעות `fgets`, עם אורך מקסימלי של 1023 תווים (0x3FF).
  ומתבצעת קריאה לפונקציה `__acrt_iob_func` לקבלת מצביע לקלט, ואז `fgets` קוראת את הטקסט ל־Buffer.

  * **חישוב אורך המחרוזת**

 האורך של המחרוזת שנקלטה נשמר במשתנה מקומי (`var_C`) באמצעות קריאה ל־`strlen`

  * **לולאת עיבוד XOR** - מבוצעת לולאה החוזרת על מחרוזת הקלט בבלוקים של 4 בתים:
    
  1. בכל איטרציה, ארבעת הבתים ב־Buffer עוברים XOR עם מפתח קבוע 0x41524241.
  2. התוצאה נשמרת בחזרה במיקום המתאים ב־Buffer.
  3. הלולאה ממשיכה כל עוד i + 3 < strlen(Buffer).
  
  * **השוואת מחרוזות**
  
  לאחר סיום הפענוח, מבוצעת השוואת מחרוזת בין התוצאה המפוענחת (Buffer) לבין המחרוזת `"into the rabbit hole"`.
  ההשוואה מתבצעת באמצעות `strncmp`.
  אם אורך המחרוזת שווה (`eax == 0`), מתבצעת קפיצה לחלק שמדפיס שהסיסמה נכונה (`loc_401413`).

  * **פונקצית סיום -**
    בסיום מתבצעת פעולת ניסוי המחסנית הקריאות (`mov esp, ebp` ו־`pop ebp`) ואז `retn`.
    
---
#### **פתרון - פענוח באמצעות סקריפט פייתון**

כדי לפתור את שלב 2 ולמצוא את הסיסמה הנכונה, היה צריך לבצע את הפעולה ההפוכה לזו שבוצעה בתוכנית —

כלומר, **לבצע XOR הפוך** על המחרוזת `"into the rabbit hole"`, בעזרת סקריפט Python -
הפונקציה xor_decrypt מבצעת XOR על המחרוזת עם אותו מפתח, ומחזירה את המחרוזת המפוענחת.

להלן הסקריפט שבוצע:


![ERD diagram](https://github.com/shirelsan/Assembly-Reversing/blob/main/case2_py.png?raw=true) 


* הסבר על הפונקציה:

הפונקציה xor_decrypt מפענחת מחרוזת בתים (bytes) על ידי שימוש במפתח XOR בן 4 בתים (32 ביט).
הפונקציה מחלקת את המחרוזת לבלוקים של 4 בתים, מבצעת על כל בלוק פעולת XOR עם המפתח, ומחזירה את התוצאה המפוענחת באותו אורך כמו הקלט.
אם הבלוק האחרון קצר מ-4 בתים, מתווספים אפסים כדי להשלים אותו.

הסיסמה שקיבלנו: **(,&.a6:$a03##+&a)->$**

![ERD diagram](https://github.com/shirelsan/Assembly-Reversing/blob/main/case2-sol.png?raw=true) 


## Exercise: Wonderland 3

