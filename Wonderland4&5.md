# Assembly Reversing Writeup - Wonderland Levels 4 & 5

Submitted by: Shirel Sananes 322328814

## Exercise: Wonderland 4

### **מטרה**

להזין קלט שיגרום לתוכנית לעבור את שתי בדיקות:

1. השוואת תוכן - הקלט צריך להתאים למחרוזת "Good luck!!"
2. השוואת כתובת - הכתובת שמכניסים צריכ להתאים לכתובת בזיכרון שבה נמצאת המחרוזת. 

### ניתוח הקוד:
1. **סוג קלט** - זיהוי הקלט המצופה בחלק הזה בקוד:
  ```asm
push    offset aDu      ; " %du"
call    scanf
  ```
 התוכנית מצפה לקלט מסוג unsigned decimal - כלומר, המספר שאני מכניסה הוא עשרוני. 
 
 2. **בדיקת התוכן** -

  ```asm
call    ds:strncmp
  ```

התוכנית משווה בין הקלט שהוזן (Str1) לבין המחרוזת שהורכבה ב־stack היא "Good luck!!".

3. **בדיקת הכתובת** -
```asm
cmp [ebp+Str1], lea [ebp+Str]
```
יש השוואה של הכתובת של הקלט לכתובת המחרוזת בזיכרון. כלומר, התוכנית בודקת אם הקלט (שאמור להיות כתובת) שווה לכתובת שבה מאוחסנת המחרוזת שהורכבה.

### שלבי הפתרון:

1. הרצתי את התוכנית ב־debugger, עם נקודות עצירה, עצרתי לפני הקריאה ל־strncmp.בשביל לבדוק מה הכתובת של המחרוזת שהורכבה ב־stack - של str:

![1](https://github.com/shirelsan/Assembly-Reversing/blob/main/image_wonder4+5/wonder4_3.jpg.png?raw=true) 

2. הכנסתי את הערך הדיצימלי של הכתובת 0x19fefc -> 1703676 אבל קיבלתי את המסר:

Cheater.. Try again another way.

4. חיפשתי בזיכרון כתובת אחרת שבה מופיעה אותה מחרוזת:

![2](https://github.com/shirelsan/Assembly-Reversing/blob/main/image_wonder4+5/wonder4.jpg?raw=true) 

מצאתי כתובת קבועה בזיכרון שבה המחרוזת קיימת - בתמונה קפיצה לכתובת 0x40473e:

![3](https://github.com/shirelsan/Assembly-Reversing/blob/main/image_wonder4+5/wonder4_2.jpg?raw=true) 

לכן המרת הכתובת 0x40473e למספר עשורני צריך העבור את שתי הבדיקות גם של התוכן וגם של הכתובת. 

### **הפתרון: 0040473e -> 4212542**

![4](https://github.com/shirelsan/Assembly-Reversing/blob/main/image_wonder4+5/sol4.jpg?raw=true) 

## Exercise: Wonderland 5

### **מטרה**
התוכנית מקבלת קלט מהמשתמש — שם קובץ. היא מנסה לפתוח את הקובץ ולבדוק את תוכנו באמצעות פונקציה (sub_401770). אם התוכן עומד בקריטריונים מסוימים, הפונקציה מחזירה 1 (הצלחה). אחרת, היא מחזירה 0 (כישלון).

**זרימת התוכנית בקצרה**
1. התוכנית מבקשת מהמשתמש להכניס שם קובץ.
2. היא מנסה לפתוח את הקובץ (CreateFileA).
3. אם הצליחה — היא סוגרת את ה־handle ומעבירה את המחרוזת שהמשתמש הקליד לבדיקה בפונקציה sub_401770.
4. הפונקציה sub_401770 מעבדת את המחרוזת ומחזירה 1 אם הכל תקין.
5. אחרת, חוזרים ומדפיסים הודעת כישלון.
   
### ניתוח מבנה הפונקציה sub_401770

**שלב 1 חתימת הפונקציה ואתחול - הפונקציה sub_401770 מתחילה באתחול סטנדרטי**
  משתנים מקומיים:
  * המשתנה var_4: מצביע למיקום הנוכחי במסלול
  * המשתנה var_8: משתנה לאחסון תו הקלט הנוכחי
  * המשתנה var_c: אינדקס במחרוזת הקלט (מונה)
    
**שלב 2 מציאת נקודת ההתחלה -**
1. הפונקציה משתמשת ב-strchr למציאת המיקום של התו 'O' במבוך
2. שומרת את הכתובת ב-var_4 (מצביע המיקום הנוכחי)
3. מאתחלת את מונה הקלט (var_C) לאפס

**שלב 3 לולאת העיבוד הראשית של הפונקציה מתחלקת לשניים קריאת תו קלט ועיבוד-**

1. **קריאת תו קלט:**

 ```asm
loc_401790:
mov     ecx, [ebp+arg_0]        ; טוען כתובת מחרוזת הקלט
add     ecx, [ebp+var_C]        ; מוסיף אינדקס נוכחי
movsx   edx, byte ptr [ecx]     ; קורא תו מהמחרוזת
mov     [ebp+var_8], edx       ; שומר את התו
```

2. **עיבוד הקלט** - הקוד מקבל תווים מהמשתמש ובודק אותם באמצעות Switch Statement:

```asm
mov     eax, [ebp+var_8]
sub     eax, 31h                ; מחסיר '1' (0x31) מהתו
mov     [ebp+var_8], eax
cmp     [ebp+var_8], 3          ; בודק אם הערך בטווח 0-3
ja      short def_4017AE        ; קפיצה לdefault אם מחוץ לטווח
```
**שלב 4 מיפוי הקלט:**

* תו '1' (ASCII 0x31) → אחרי החיסור: 0 → case 0 (ימינה)
* תו '2' (ASCII 0x32) → אחרי החיסור: 1 → case 1 (למטה)
* תו '3' (ASCII 0x33) → אחרי החיסור: 2 → case 2 (שמאלה)
* תו '4' (ASCII 0x34) → אחרי החיסור: 3 → case 3 (למעלה)

כלומר, כל שורה במבוך היא בדיוק 16 בייט, כפי שרואים מחיבור או חיסור של 0x10.

**שלב 5 בדיקת תנועה חוקית והגעה ליעד**

1. **בדיקת תנועה חוקית**- לאחר כל תזוזה במפה, הקוד בודק אם המיקום החדש תקין (כלומר, אם התנועה עברה על נקודה '.'):
```asm
mov     eax, [ebp+var_4]        ; טוען את המצביע למיקום הנוכחי במפה
movsx   ecx, byte ptr [eax]     ; קורא את התו שנמצא במיקום החדש
cmp     ecx, 2Eh                ; משווה את התו לנקודה '.' (0x2E)
jz      short loc_401790        ; אם התו הוא נקודה, המהלך חוקי וממשיכים בלולאה
```

*אם המיקום אליו הזנו מכיל נקודה (0x2E) נמשיך להריץ את הלולאה ולבצע את הצעד הבא בקלט. 

*אם המיקום אינו נקודה, התוכנית תצא מהלולאה.
  
2. **בדיקת הגעה ליעד** - לאחר שנפלה ההתניה על נקודה (או במקרה שהתו אינו נקודה), נבדק האם הגענו ליעד (תו X):
```asm
loc_401806:
mov     edx, [ebp+var_4]        ; טוען את המצביע למיקום הנוכחי במפה
movsx   eax, byte ptr [edx]     ; קורא את התו במיקום זה
cmp     eax, 58h                ; משווה את התו ל-'X' (0x58)
jnz     short loc_40181A        ; אם לא 'X', ממשיכים הלאה (יעד לא הושג)
```

• אם הגענו ל־'X', התנאי מצליח והפונקציה תחזיר הצלחה (ערך 1).

• אם לא הגענו ל־'X', הלולאה מסתיימת עם כישלון (ערך 0).

### לסיכום - 
בכל צעד בלולאה, הקוד קורא את התו במיקום החדש שאליו הגענו לאחר ביצוע תנועה.

• אם התו הוא נקודה ('.'), המהלך חוקי, הלולאה ממשיכה והקלט הבא נבדק.

• אם התו אינו נקודה, נבדקת האפשרות שהגענו ליעד: אם התו הוא 'X', הלולאה מסתיימת בהצלחה ומוחזר ערך 1.

• אם התו אינו 'X', הלולאה מסתיימת בכישלון ומוחזר ערך 0.

• התהליך ממשיך עד שמסתיים הקלט או עד שמגיעים ליעד.

### **שלבי הפתרון**
1. **זיהוי המיקומים** - מניתוח הדאטה הגולמית:

  ![4](https://github.com/shirelsan/Assembly-Reversing/blob/main/image_wonder4+5/wonder5_1.jpg.png?raw=true) 
2. מיקומים חשובים:

* התו **O** (התחלה): **0x404033**
* התו **X** (יעד): **0x40406D**

תיעוד המסלול שנמצא:
(באמצעות רצף של מספרים המייצגים את הכיוונים 1 = ימינה, 2 = למטה, 3 = שמאלה, 4 = למעלה)

1. **222** -3 פעמים למטה
2. **111** - ימינה 3 פעמים
3. **44** - למעלה פעמיים
4. **11** - ימינה פעמיים
5. **4** - למעלה פעם אחת
6. **11** - פעמיים ימינה
7. **222** שלוש פעמים למטה
8. **111** - 3 פעמים ימינה

### **המסלול הנמצא**

רצף הספרות הנכון שנמצא:**2221114411411222111**

![4](https://github.com/shirelsan/Assembly-Reversing/blob/main/image_wonder4+5/wonder5_sol.jpg?raw=true) 

לאחר הבדיקה של הפונקציה היא מחזירה את eax אם הוא שווה 1 הפונקציה תעבור למסר ההצלחה ואם הוא 0 יודפס מסר כישלון

  ![4](https://github.com/shirelsan/Assembly-Reversing/blob/main/image_wonder4+5/wonder5_4.jpg.png?raw=true) 

